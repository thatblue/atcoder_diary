# 経験則

概ね方針が出ているのにスッと解けない場合は読む。

- D問題でも全探索が必要なケースはある。問題文のデータ量制約はきちんと読み込むこと。
    - データ数が10個未満だと組み合わせ全探索出来るかも
        - 10～20個ならbit全探索の可能性を検討する
    - 1000個くらいならN*Nの二次元DPができる
    - 10^5くらいだとN*Nの二重ループが間に合わないので、事前のソートとか二分探索とか一次元DPなどなど工夫する必要がある
- 配列のインデックスの取り回しに気を付ける。問題文は大体1-indexになっているが、ダミーデータを詰めてインデックスを動かすか読み替えをするかでうまくやる。
- DPするときは初期値に注意。負数が入りうるときに0を詰めたり、最小値を取りたいときに適当な値が小さすぎたりしないように気を付ける。
- DFSとBFSは互換性のあるケースが多い。DFSで解いてみてTLEが10個～半分弱くらい出るようであればBFSでの書き換えを検討する、逆もしかり。
- 1と0だったり、#と.だったり、boolで表現出来るときはビット演算を使うと早いケースがある。
- 見た目がグラフだとDFS/BFSをやりたくなりがちだが、D問題以上ではDPやUnionFindの可能性も検討する。
- コンテストの問題においてbsearch_indexを素朴に適用できるケースはかなりレア。
- DPだからと言って素朴に二次元配列を作るとランタイムエラーを起こすことがある。ハッシュの利用も検討する。
- 問題文で「剰余を出す」って言われるようなケースでべき乗したいときは `Integer#pow` を使って第二引数を必ず指定すること。
- `Math#sqrt` や `Math#log2` みたいなfloatが返ってくる処理は出力直前にやる。大小比較だけなら処理前の値でも可能。
- 約数列が欲しいときは `Math.sqrt(n)` まで探せば十分。sqrtの端数は切り捨てでOK。


